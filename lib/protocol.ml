(** use buffered reading / writing globally *)
module Write = Eio.Buf_write
module Read = Eio.Buf_read

(** All internal reading / writing done in big endian *)
module ReadInt = Read.LE
module WriteInt = Write.LE


(** Local message ids are generated by this chat engine
    and sent in outgoing message headers. *)
type local_msg_id = Local of int


(** Remote message ids are generated by remote chat engines
    and are received in the header of incoming messages. *)
type remote_msg_id = Remote of int


let max_message_size = Int.max_int

(** Message header type tags *)
let acknowledge_tag = Char.chr 0b1111
let message_tag     = Char.chr 0b1110
let handshake_tag   = Char.chr 0b1101

(** Handshake protocol message bodies *)
let handshake_server_to_client_req = Char.chr 0b1100
let handshake_client_to_server_ok  = Char.chr 0b1011
let handshake_server_to_client_ok  = Char.chr 0b1010

let read_tag = Read.any_char
let write_tag = Write.char

let read_handshake_body = Read.any_char
let write_handshake_body = Write.char

let read_length r = ReadInt.uint32 r |> Int32.to_int
let write_length r i = Int32.of_int i |> WriteInt.uint32 r

let read_id r = ReadInt.uint32 r |> Int32.to_int
let write_id r i = Int32.of_int i |> WriteInt.uint32 r


(* Handshake network operations *)

(** The handshake operation sequence for clients *)
let client_handshake_seq =
  [ `Recv, `HandshakeRequest
  ; `Send, `HandshakeClientOk
  ; `Recv, `HandshakeServerOk
  ]


(** The handshake operation sequence for the server *)
let server_handshake_seq =
  [ `Send, `HandshakeRequest
  ; `Recv, `HandshakeClientOk
  ; `Send, `HandshakeServerOk
  ]


(** Convert the handshake message type to an integer tag *)
let handshake_to_body_code = function
  | `HandshakeRequest -> handshake_server_to_client_req
  | `HandshakeClientOk -> handshake_client_to_server_ok
  | `HandshakeServerOk -> handshake_server_to_client_ok


(** Send a handshake message, returns true on success, false otherwise. *)
let send_handshake msg ~socket =
  try
    let msg_body = handshake_to_body_code msg in
    Write.with_flow socket @@ fun outbound ->
    write_tag outbound handshake_tag;
    write_handshake_body outbound msg_body;
    true
  with
    _ -> false


(** Receive a handshake message with the [expected] tag.
    Returns true on success, false otherwise. *)
let receive_handshake expected ~socket =
  let expected_body = handshake_to_body_code expected in
  let inbound = Read.of_flow socket ~max_size:16 in
  let tag = read_tag inbound in
  if tag <> handshake_tag then
    false
  else
  expected_body = read_handshake_body inbound


(** Runs the handshake sequence [ms], returns true
    if the sequence is completed properly. *)
let run_handshake_seq ~socket ms =
  List.for_all (function
    | `Send, msg -> send_handshake msg ~socket
    | `Recv, msg -> receive_handshake msg ~socket) ms


(** Send an outgoing message with the local message [id]
    and the body contents of [bytes]. *)
let send_message (Local id) bytes flow =
  try
    let msg_len = Stdlib.Bytes.length bytes in
    write_tag flow message_tag;
    write_id flow id;
    write_length flow msg_len;
    Write.bytes flow ~len:msg_len bytes
    |> Option.some
  with
    _ -> Option.None


(** Send an acknowledgement for the remote message [id]. *)
let send_acknowledge (Remote id) flow =
  try
    write_tag flow acknowledge_tag;
    write_id flow id
    |> Option.some
  with
    _ -> Option.None


(** Receive an incoming message over [socket]. *)
let receive flow =
  try
    let tag = read_tag flow in
    if tag = acknowledge_tag then
      `Acknowledge (Local (read_id flow))
      |> Option.some
    else if tag = message_tag then
      let id = read_id flow
      and msg_len = read_length flow in
      let received_bytes = Read.take msg_len flow |> Bytes.of_string in
      `Message (Remote id, received_bytes)
      |> Option.some
    else
    Option.None
  with
    _ -> Option.None


let error_msg_to_string = function
| `Invalid_id -> "Invalid message id used"
| `Recv_fail -> "Network read failed"
| `Send_fail -> "Network send failed"
| `Ui_read_fail -> "Reading from UI failed"
| `Ui_write_fail -> "Writing to UI failed"
